import pages from "/src/components/pages"
import {Diagram} from "/src/components/diagrams/Diagram";

# Introduction


Connected Objects are a powerful evolution of Network Objects.<br></br>
They comes with an enhanced and configurable RMI system.

See the <a href={pages.gnom.caches.connected_objects.getting_started}>next page</a> to know how to start with connected objects.<br></br>
Make sure you understood the <a href={pages.gnom.naming.index}>Network Objects concept</a> in order not to get lost while reading this part.

Some reminders:
- An Engine is a connection in a Linkit Network. It can either be the server or a client connection.
- The linkit's network operates in a <a href="https://learnlearn.uk/alevelcs/wp-content/uploads/sites/20/2020/02/star-topology.png">star topology</a>.
In the diagrams below you'll see arrows directly pointing toward engines.
This is to simplify the diagrams as the topology is not important here.

## Summary

Roughly, Connected objects are Network Objects that gets handled by an <orange>RMI system</orange>.
This RMI system follows a <orange>contract</orange> that says what should happen when a connected object's method get invoked.
The <orange>contract</orange> is the <orange>most important</orange> part of the <orange>Connected Object System</orange>.
By configuring a contract, you specify how your connected objects will <orange>behave</orange> over the <orange>network</orange>.

The Features list below will introduce to things you can do with connected objects.<br></br>
Some features are not concerned by the contract.

# Features

### Simple Remote Method Invocations (RMIs)

```scala
class MyObject {
    def foo(): Unit = print("foo called !")
}
```

<Diagram light={require("/src/components/diagrams/Connected Object/Features/Simple RMI.svg")}
         dark={require("/src/components/diagrams/Connected Object/Features/Simple RMI.svg")}
         style={{width: "75%", height: "75%", display: "block", margin: "auto"}}/>

<details>
    <summary>Broadcast any method invocation on remote engines</summary>
    <div>
        All method invocations can be spread out on other engines in order to simulate a "cloud" object being accessed
        from other engines and which internal state is completely synchronized.
    </div>
</details>

### Flow control (agreements).
Control who receives an invocation when a method get called, and who we choose to return a result.

```scala
class MyObject {
    /**
     * This method prints a param and return the current JVM version.
     * */
    def doSomething(param: String): String = {
        print(s"invocation called ! ($param)")
        System.getProperty("java.version")
    }
}
```

<Diagram light={require("/src/components/diagrams/Connected Object/Features/RMI Agreements.svg")}
         dark={require("/src/components/diagrams/Connected Object/Features/RMI Agreements.svg")}
         style={{width: "100%", height: "100%", display: "block", margin: "auto"}}/>

<details>
    <summary>Invocation Agreements</summary>
    <div>
        You can define a contract for methods and specify agreements that controls the invocation flow over the network.<br></br>
        As the example shows, it's also possible to <orange>appoint</orange> an engine that'll have to return a result
        when performing a call on multiple engines<br></br>
    </div>
</details>

#### Also supports simple conditions

<Diagram light={require("/src/components/diagrams/Connected Object/Features/RMI Agreements - Conditions.drawio.svg")}
         dark={require("/src/components/diagrams/Connected Object/Features/RMI Agreements - Conditions.drawio.svg")}
         style={{width: "100%", height: "100%", display: "block", margin: "auto"}}/>


You can define some constraints on your agreements depending on the initial method execution context:

<Diagram
    light={require("/src/components/diagrams/Connected Object/Features/RMI Agreements - Conditions (Contract).drawio.svg")}
    dark={require("/src/components/diagrams/Connected Object/Features/RMI Agreements - Conditions (Contract).drawio.svg")}
    style={{width: "50%", height: "50%", display: "block", margin: "auto"}}/>

:::note
On the diagram, the object is red for the engine that initially owns the object.<br></br>
Connected Object owners are the engines that initially posted their objects over the network.
:::

### Know who is the invocation origin

Using the static method `ExecutorEngine.currentEngine`, you can know who is the origin of the execution of a method.
This is actually very powerfull for making APIs and client-server actions as you can choose to perform different actions depending on the client
that is performing a _request_

```scala
class MyObject {
    /**
     * This method prints who originally invocated the method.
     * */
    def printInvoker(): Unit = {
        val trigerrer = ExecutorEngine.currentEngine
        print(s"invocation called ! this RMI has been triggered from " + trigerrer.identifier)
    }
}
```

<Diagram light={require("/src/components/diagrams/Connected Object/Features/ExecutorEngine.svg")}
         dark={require("/src/components/diagrams/Connected Object/Features/ExecutorEngine.svg")}
         style={{width: "75%", height: "75%", display: "block", margin: "auto"}}/>

### Static accesses

### Apply modifiers on parameters and return values

### Inner object connection

#### Also Connect field values of connected objects

#### Also Connect param and return values on method invocations

### Remote Implementation control

This is actually one of the most powerful possibility of Connected Objects.